[{"content":"DOM (돔) 정의  Document Object Model 그리고 문서 객체 모델이며 HTML 및 XML 문서를 위한 API이다. 이 DOM이란 트리 구조로 되어있는 객체 모델로써, Javascript가 getElementbyid()를 같은 함수를 이용하여 HTML문서의 각 요소(li, head같은 태그들)들을 접근하고 사용할 수 있도록 하는 객체 모델이다. 브라우저마다 DOM을 구현하는 방식은 다르기에 DOM이라는 것이 구체적으로 정해저 있는 언어나 모델과 같은 것은 아니다. 다만 웹페이지를 객체로 표현한 모델을 의미할 뿐이다.  DOM 의 트리구조 예시 브라우저가 돔을 이용해서 화면을 렌더링 하는 방법 예시 첫째, 브라우저는 html태그를 파싱 하여 돔 트리를 구성한다. 동시에 브라우저는 스타일시트에서 css를 파싱 하여 스타일 규칙들을 만들어낸다. 둘째, 위에서 언급한 돔 트리와 스타일 규칙 두 가지가 합쳐져서 렌더 트리를 만들어낸다.\nVIRTUAL DOM (가상 돔) 정의  A virtual DOM is a lightweight JavaScript representation of the DOM used in declarative web frameworks such as React, Vue.js, and Elm. Updating the virtual DOM is comparatively faster than updating the actual DOM, since nothing has to be rendered onto the screen. - Wikipedia -\n가상돔이란 돔을 가볍게 만든 자바스크립트 표현이라고 할 수 있고 주로 React, Vue.js 그리고 Elm에 사용된다. 가상돔은 실제로 스크린에 랜더링을 하는것이 아니기에 돔을 직접 업데이트 하는것보다 상대적으로 빠르다.\n 필요성및 차이점 돔의 문제  SPA (Single Page Application)의 출현으로 가상 돔이 매우 필요해졌다.\n DOM은 트리구조로 되어있어서 이해하기 쉽다는 장점은 있으나, 이 구조는 거대해 질때 속도가 느려지고, DOM 업데이트에 잦은 오류를 야기한다. DOM을 분석하는데에도 힘든 단점이 있다.\n그런데 최근 모던 웹은 SPA(Single Page Application) 을 사용한다. 하나의 웹 페이지를 어플리케이션 처럼 구성하는 SPA에서는 HTML 문서 자체가 하나이며, Application이라 칭 할 만큼 여러 동적인 기능(실시간 기능)들이 들어가기 때문에 안그래도 리소스가 모두 합쳐진 HTML 문서를 지속적으로 재 렌더링 해주어야 하는 문제점이 발생하게 되었다.\n기존에는 화면의 변경사항을 돔을 직접 조작하여 브라우저에 반영하였다. 하지만, 이 방법의 가장 큰 단점은 돔 트리가 수정될 때마다 렌더 트리가 계속해서 실시간으로 갱신된다는 점이었다. 즉, 화면에서 10개의 수정사항이 발생하면 수정할 때마다 새로운 랜더 트리가 10번 수정되면서 새롭게 만들어지게 되는 것이다.\n그래서 가상 돔이 출현   가상돔(Virtual DOM)은 실제 DOM 문서를 추상화한 개념으로, 변화가 많은 View를 실제 DOM에서 직접 처리하는 방식이 아닌 Virtual Dom과 메모리에서 미리 처리하고 저장한 후 실제 DOM과 동기화 하는 프로그래밍 개념입니다.\n  해당 DOM을 컴포넌트 단위로 쪼개어 HTML 컴포넌트 조립품 처럼 다루는 개념이다. 이 조립품들이 VirtualDOM이라 할 수 있다.\n  Vue, React는 가상 돔 방식을 채택했다.\n     돔 가상돔     업데이트가 느리다. 업데이트가 빠르다.   HTML을 직접적으로 업데이트 한다. HTML을 직접적으로 업데이트 하지 않는다.   새로운 element가 업데이트 된 경우 새로운 DOM을 생성한다. 새로운 element가 업데이트 된 경우 새로운 가상돔 생성한 후 이전 돔과 비교하여 차이를 계산 이후 돔을 업데이트한다.   메모리 낭비가 심하다. 메모리 낭비가 덜하다.    *업데이트가 빠른것은 가상돔이 돔보다 빠르다는 표현과는 다르다. VDOM의 주목적은 DOM의 직접적 변화의 수를 줄이는데 있고 이 변화가 느린것이다.\n아래와 같은 코드 돔은 브라우저가 핸들하여 생성한다.\n\u0026lt;ul class=\u0026#34;fruits\u0026#34;\u0026gt; \u0026lt;li\u0026gt;Apple\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Orange\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Banana\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Virtual DOM 식으로 표현된 코드 React, Vue 등의 모던 프레임워크가 실제 돔과 비슷한 가상돔을 메모리에 생성한다.\n// Virtual DOM representation { type: \u0026#34;ul\u0026#34;, props: { \u0026#34;class\u0026#34;: \u0026#34;fruits\u0026#34; }, children: [ { type: \u0026#34;li\u0026#34;, props: null, children: [ \u0026#34;Apple\u0026#34; ] }, { type: \u0026#34;li\u0026#34;, props: null, children: [ \u0026#34;Orange\u0026#34; ] }, { type: \u0026#34;li\u0026#34;, props: null, children: [ \u0026#34;Banana\u0026#34; ] } ] } 출처\n가상돔의 Three Steps   어떠한 데이터의 변화가 일어났을때, 전체 UI가 가상 돔에서 재 랜더링이 된다.\n  이전 돔과 새로운 가상돔의 차이가 계산된다.   계산이 끝난 후, 돔은 변경된 부분만을 변화시킨다.   REACT/Vue.js/Angular/Elm 가 사용하는 가상 돔 첫 번째로 가상 돔은 리액트에서 나온 개념이 아니다.\n하지만 리액트는 무료로 이 개념을 사용하고 사용자들에게 제공한다. 퍼포먼스와 메모리 관리가 효율적으로 가능하게 되었다. 가상 돔을 활용하면 이러한 불필요한 렌더링 횟수를 줄일 수 있다. 가상 돔을 활용한 대표적인 프런트 앤드 프레임워크가 리액트, 뷰, 앵귤러이다. 이러한 프레임워크들은 화면에 변화가 있을 때마다 실시간으로 돔 트리를 수정하지 않고 변경사항이 모두 반영된 가상 돔을 만들어낸다. 그 후 가상 돔을 이용해 한 번만 돔수정을 하게 되고 이는 한 번만 렌더 트리를 만들어내게 된다. 결과적으로 브라우저는 한번만 렌더링을 하게 됨으로써 불필요한 렌더링 횟수를 줄일 수 있게 되는 것이다.\n\u0026lt; 추가 링크 \u0026gt; https://bitsofco.de/understanding-the-virtual-dom/\n","permalink":"https://ajdeve.github.io/post/domvsvdom/","summary":"DOM (돔) 정의  Document Object Model 그리고 문서 객체 모델이며 HTML 및 XML 문서를 위한 API이다. 이 DOM이란 트리 구조로 되어있는 객체 모델로써, Javascript가 getElementbyid()를 같은 함수를 이용하여 HTML문서의 각 요소(li, head같은 태그들)들을 접근하고 사용할 수 있도록 하는 객체 모델이다. 브라우저마다 DOM을 구현하는 방식은 다르기에 DOM이라는 것이 구체적으로 정해저 있는 언어나 모델과 같은 것은 아니다. 다만 웹페이지를 객체로 표현한 모델을 의미할 뿐이다.  DOM 의 트리구조 예시 브라우저가 돔을 이용해서 화면을 렌더링 하는 방법 예시 첫째, 브라우저는 html태그를 파싱 하여 돔 트리를 구성한다.","title":"DOM vs. Virtual DOM"},{"content":"Servlet \u0026amp; JSP 정의 Servlet: 서블렛은 Java class로서 서버의 요청을 다루기 위해 쓰인다.\n 서블렛을 통해 사용자의 input을 모으거나, DB에서 레코드를 출력한다거나 dynamic web page들을 생성하거나 할 수 있다. 쉽게 말하면 \u0026ldquo;클라이언트의 요구를 받아 그에 대한 처리를 한 후, 결과를 되돌려주는 서버 모듈\u0026quot;이다. 서블릿은 JSP에서 컨텐츠와 비즈니스 로직을 분리한다. JSP가 텍스트 파일 구조인데 비해 서블릿은 자바 클래스 구조이다.  출처: https://ddo-o.tistory.com/77 [공순이의 블로그]\nServlet 돌아가는 과정 서블렛은 Servlet Container (서블렛 컨테이너)에게서 컨트롤된다. 서버가 요청을 받을때 서버가 요청을 서블렛 컨테이너에게 넘겨주고, 서블렛 컨테이너가 요청을 처리하기 위한 서블렛에게 전달한다.\n Client가 웹 서버에 요청을 보낸다. 서버가 요청을 받고 서블렛 컨테이너가 HttpServletRequest, HttpServletResponse 두 객체를 생성한다. 서블렛 컨테이너가 가 해당 담당하는 서블렛으로 요청을 보낸다. 서블렛이 요청을 process하고 응답을 생성한다. (컨테이너가 서블렛 service() 메소드를 호출해서 POST, GET여부에 따라 doGet() 또는 doPost()를 호출하여 동적인 페이지를 생성함, 서블렛이 웹 서버에 HttpServletResponse 객체에 응답을 보낸다. 서버가 응답을 client에게 다시 보내고 client 브라우저는 스크린에 출력한다. 그리고 HttpServletResponse \u0026amp; Request 객체를 소멸시킨다.  Servlet Life Cycle  서블렛 로딩: 서버가 시작할때 모든 서블렛을 로딩한다. 서블렛 시작: init() 메소드로 서블렛이 시작  public void init() throws ServletException { // Initialization code like set up database etc.... } 요청 처리: service() 메소드로 client의 요청을 처리하며 서블렛에게 client의 요청을 알린다.  public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { // ... } 서블렛을 종료: destroy() 메소드로 서블렛이 종료됨. 서블렛의 라이프 사이클에서 단 한번 실행됨  public void destroy() { // }  init()과 destroy() 메소드는 한번 실행됨  JSP: Java Server Page 정의: Java 언어를 기반으로 하는 Server Side 스크립트 언어\n 자바 서버 페이지는 서블렛과 같이 웹앱을 만들기위한 기술이며, JSTL등등 다양한 표현법을 사용해서 더 많은 기능을 구현할 수 있다. 서버쪽의 기술 JSP tag 는 JAVA 코드를 HTML 페이지에 넣을때 사용한다. HTML 코드에 Java 코드를 넣어 동적인 웹 페이지를 생성하는 웹 어플리케이션 도구 JSP는 JSP 컨테이너에 의해서 client 요청을 처리하기전에 servlet으로 변환된다. Servlet 기술의 확장 Servlet를 보완한 스크립트 방식 표준 Servlet의 모든 기능 + 추가적인 기능  JSP Life Cycle  JSP를 서블렛으로 변환한다. JSP 페이지를 컴파일한다. _jsp.java 가 class file_jsp.class로 변환된다. Object of generated servlet is created. _jspinit() 메소드가 컨테이너로 시작된다. _jspservice() 메소드가 컨테이너에 의해 요청을 처리한다. _jspDestroy() 메소드가 실행되어 컨테이너에 의해 종료된다.  Code Example   Declaration Tag :-메서드와 변수 모두 선언할 수 있다.\njava\r**Syntax:-** \u0026lt;%! Dec var %\u0026gt;\r**Example:-**\r\u0026lt;%! int var=10; %\u0026gt;\r\n  Java Scriplets :- 임의의 자바코드 대부분은 여기 가능하다. Method가 아닌 변수만 선언할 수 있다. java\r**Syntax:-** \u0026lt;% java code %\u0026gt;\r\n  JSP Expression :- String으로 변환되어 Servlet의 출력에 삽입된다. 끝에 \u0026ldquo;;\u0026rdquo; 세미콜론을 붙이지 않는다.\njava\r**Syntax:-** \u0026lt;%= expression %\u0026gt; **Example:-** \u0026lt;% num1 = num1+num2 %\u0026gt; \n  JAVA Comments :-주석달기 java\r**Syntax:-** \u0026lt;% -- JSP Comments %\u0026gt;\r\n  JAVA Comments :-주석달기 java\r**Syntax:-** \u0026lt;% -- JSP Comments %\u0026gt;\r\n  JAVA Directive : -JSP 페이지의 전체적인 구조에 영향을 미친다. 전체 구조에 대해 WAS에 지시를 내린다. 지시어에 들어가는 것: page, include, taglib java\r\u0026lt;%@ directive %\u0026gt;\r   page: page 지시어는 Container에 명령을 제공하는데 사용된다.\n\u0026lt;%@ page attribute = \u0026#34;value\u0026#34; %\u0026gt; include: include 지시어는 변환 단계에서 다른 외부 파일의 내용을 현재 JSP에 병합하도록 Container에 지시한다.\n\u0026lt;%@ include file = \u0026#34;relative_url\u0026#34; %\u0026gt; taglib: JSP API를 사용하면 HTML 또는 XML 태그처럼 보이는 사용자 정의 태그(custom tags)를 정의할 수 있다. tag library는 사용자가 정의한 동작을 구현한 사용자 정의(user-defined) 태그 집합이다.\n\u0026lt;%@ taglib uri = \u0026#34;uri\u0026#34; prefix = \u0026#34;prefixOfTag\u0026#34; %\u0026gt; JSP Action JSP Action XML 구문 안의 구조들을 사용하여 WAS의 동작을 제어한다. \u0026lt;jsp:forward\u0026gt; action 다른 리소스(JSP, html 또는 Servlet과 같은 정적 페이지)로 요청을 전달하는데 사용한다. \u0026lt;jsp:include\u0026gt; action 현재 JSP 페이지에 다른 리소스를 포함시키는데 사용한다. \u0026lt;jsp:useBean\u0026gt; action 해당하는 Bean(자바 객체)이 이미 존재하는지 확인한다. 객체가 없으면 지정된 객체를 생성한다. \u0026lt;jsp:setProperty\u0026gt; action Bean(자바 객체)의 속성을 설정한다. \u0026lt;jsp:getProperty\u0026gt; action 주어진 속성값을 가져오는데 사용되며 이를 문자열로 변환하고 동적인 웹 페이지를 생성하는데 해당 내용을 사용할 수 있다.  용도\n 동적으로 파일을 삽입하고 JavaBeans 구성 요소를 재사용하고 사용자를 다른 페이지로 전달(forward)할 수 있다. https://gmlwjd9405.github.io/2018/11/03/jsp.html  JSP EL (Explression Language)  \u0026lt;%-- JSP 2.0(Preferred) --%\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Name: ${customer.name}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Email: ${customer.email}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;ID: ${customer.id}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; **JSP JSTL ** JSP Scriptlet에서 JSTL로!  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Count to 10 in JSP scriptlet\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;% for(int i=1;i\u0026lt;=10;i++){ %\u0026gt; \u0026lt;%=i%\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;%@ taglib uri=\u0026#34;http://java.sun.com/jsp/jstl/core\u0026#34; prefix=\u0026#34;c\u0026#34;%\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Count to 10 Example (using JSTL)\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;c:forEach var=\u0026#34;i\u0026#34; begin=\u0026#34;1\u0026#34; end=\u0026#34;10\u0026#34; step=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;c:out value=\u0026#34;${i}\u0026#34;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/c:forEach\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 차이점 기능은 동일하나 역할은 다르다.    Servlet JSP     JAVA code html 기반 code   MVC 구조의 Controller 역할 MVC 구조의 View 역할   JSP 보다 빠름 JSP 는 JSP를 자바 코드로 번역하는 과정을 먼저 거치고 컴파일이 필요해서 Servlet보다 느림   모든 protocol 요청을 받음 http 요청만 받음   주된 업무는 client에게 정보를 입력받아 적절한 HTML문서를 돌려주는 역할. JSP는 실행시키면 이 문서가 자동적으로 서블렛으로 컴파일 되어서 실행됨    Request \u0026amp; Response HttpServletRequest  사용자가 서버로 보낸 요청: Request http프로토콜의 request정보를 서블렛에게 전다하는 목적으로 사용됨 헤더정보, 파라미터, 쿠키, URL등의 정보를 읽고 처리하는 메소드를 가지고 있음 body의 stream을 읽어 들이는 메소드를 가지고 있음     메소드 설명     getParameter(?) 요청에 담긴 값을 반환   getAttribute(?) 요청의 속성 값 가져오기   getAttribute(?) 요청의 속성 값 추가   request.getCookies() 쿠키에 대한 정보   request.getSession() 세션에 대한 정보   request.getRequestDispatcher() *     RequestDispatcher는 클라이언트로부터 최초에 들어온 요청을 JSP/Servlet 내에서 원하는 자원으로 요청을 넘기는(보내는) 역할을 수행하거나, 특정 자원에 처리를 요청하고 처리 결과를 얻어오는 기능을 수행하는 클래스입니다.  출처: https://dololak.tistory.com/502 [코끼리를 냉장고에 넣는 방법]\nHttpServletResponse  웹서버의 응답: Response Servlet Container.는 어떤 client가 요청을 보냈는지 알고 있고 해당 client에게 응답을 보내기 위한 HttpServletResponse객체를 생성해서 서블렛에 전달한다. 서블렛은 해당 객체를 이용해 content type, 응답코드, 응답 메세지등을 전송한다. JSP를 활용할 경우, JSP 페이지의 실행 결과를 웹 브라우저에 되돌려 줄 때 사용하는 객체     메소드 설명     PrintWriter getWriter() 응답에 char data를 보내기 위한 방법   setContentType(String) MIME 타입 지정및 글자의 인코딩 지정   response.SendRedirect(url) 웹 서버가 웹 브라우저에게 지정한 페이지로 이동하도록 지시    Servlet Code Example package step01.method; import java.io.IOException; import javax.servlet.Servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /* * client가 요청하는 url값 설정 annotation * https://ip:port/project명/[directory]/file명.html * https://ip:port/project명/[directory]/servletURL매핑값 * http://localhost/step01_basic/encore01 * encore01 -\u0026gt; alias */ @WebServlet(\u0026#34;/encore01\u0026#34;) public class Servlet01Method extends HttpServlet implements Servlet { //get 방식 요청시 자동 호출되는 메소드 \tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;doGet()\u0026#34;); //client가 입력한 데이터 획득 - 문자열 간주 \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \tString id = request.getParameter(\u0026#34;id\u0026#34;); //무조건 반환 타입이 String입니다. id key 자체가 없을 경우 null값 반환 \tString pw = request.getParameter(\u0026#34;pw\u0026#34;); //\t//접속한 client한테 한글 응답 //\t//mime type \u0026amp; 한글 응답이 가능한 설정 //\tresponse.setContentType(\u0026#34;text/html;charset=utf-8\u0026#34;); //\tPrintWriter out =response.getWriter(); \tif(id.equals(\u0026#34;SMITH\u0026#34;) \u0026amp;\u0026amp; pw.equals(\u0026#34;11\u0026#34;)) { //forward \trequest.getRequestDispatcher(\u0026#34;success\u0026#34;).forward(request, response); }else { //redirect \tresponse.sendRedirect(\u0026#34;fail\u0026#34;); } }\t//post 방식 요청시 자동 호출되는 메소드 \tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;doPost*()\u0026#34;); //요청 객체에 한글이 포함되어 있을 경우 깨짐 현상 방지를 위한 설정 \trequest.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); System.out.println(request.getParameter(\u0026#34;name\u0026#34;)); String id = request.getParameter(\u0026#34;id\u0026#34;); //무조건 반환 타입이 String입니다. id key 자체가 없을 경우 null값 반환 \tString pw = request.getParameter(\u0026#34;pw\u0026#34;); if(id.equals(\u0026#34;SMITH\u0026#34;) \u0026amp;\u0026amp; pw.equals(\u0026#34;11\u0026#34;)) { //forward \trequest.getRequestDispatcher(\u0026#34;success\u0026#34;).forward(request, response); }else { //redirect \tresponse.sendRedirect(\u0026#34;fail\u0026#34;); } } } \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Web Form Test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;이름과 성을 입력하세요.\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;encore01\u0026#34; method = \u0026#34;post\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;fname\u0026#34;\u0026gt;아이디:\u0026lt;/label\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;label for=\u0026#34;lname\u0026#34;\u0026gt;비밀번호:\u0026lt;/label\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;pw\u0026#34;\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 이름 : \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;로그인\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://ajdeve.github.io/post/servlet-jsp/","summary":"Servlet \u0026amp; JSP 정의 Servlet: 서블렛은 Java class로서 서버의 요청을 다루기 위해 쓰인다.\n 서블렛을 통해 사용자의 input을 모으거나, DB에서 레코드를 출력한다거나 dynamic web page들을 생성하거나 할 수 있다. 쉽게 말하면 \u0026ldquo;클라이언트의 요구를 받아 그에 대한 처리를 한 후, 결과를 되돌려주는 서버 모듈\u0026quot;이다. 서블릿은 JSP에서 컨텐츠와 비즈니스 로직을 분리한다. JSP가 텍스트 파일 구조인데 비해 서블릿은 자바 클래스 구조이다.  출처: https://ddo-o.tistory.com/77 [공순이의 블로그]\nServlet 돌아가는 과정 서블렛은 Servlet Container (서블렛 컨테이너)에게서 컨트롤된다.","title":"Servlet \u0026 JSP"},{"content":"Vue.js 정의 Vue.js Frontend를 쉽게 접근할 수 있게 하는 JS library\nMVVM Pattern MVC와 비슷하지만 다른 MVVM 패턴\nMVC VS. MVVM MVC: Controller와 Model이 Backend, View가 Frontend MVVM: 모든 요소가 Front이며 Javascript \u0026amp;HTML\n설치 Vue.js 사이트에서 설치 script 가져와 Head tag 전에 삽입 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 중요 문법 Vue Instance 와 Key Attribute \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input tyv-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;  \u0026lt;script\u0026gt; let model = { \u0026#34;name\u0026#34;: \u0026#34;hugo\u0026#34;}; let vm = new Vue({ el: \u0026#34;app\u0026#34;, data: model }); \u0026lt;/script\u0026gt; 중요 문법: v-show, v-if, v-if-else v-show와 v-if\n v-show는 style = display:none; 을 설정해서 condition filtering을 통해 모든 결과중 필요한 결과를 보여주는것 v-if 는 스타일 태그에 관한 변화가 아니라 필터링 된 결과만 출력  ","permalink":"https://ajdeve.github.io/post/vue.js/","summary":"Vue.js 정의 Vue.js Frontend를 쉽게 접근할 수 있게 하는 JS library\nMVVM Pattern MVC와 비슷하지만 다른 MVVM 패턴\nMVC VS. MVVM MVC: Controller와 Model이 Backend, View가 Frontend MVVM: 모든 요소가 Front이며 Javascript \u0026amp;HTML\n설치 Vue.js 사이트에서 설치 script 가져와 Head tag 전에 삽입 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 중요 문법 Vue Instance 와 Key Attribute \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input tyv-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;  \u0026lt;script\u0026gt; let model = { \u0026#34;name\u0026#34;: \u0026#34;hugo\u0026#34;}; let vm = new Vue({ el: \u0026#34;app\u0026#34;, data: model }); \u0026lt;/script\u0026gt; 중요 문법: v-show, v-if, v-if-else v-show와 v-if","title":"Vue.js 시작"},{"content":"Thread VS. Process Thread VS. Process 프로세스는 독립적이며 프로세스 안에는 스레드가 있다. 프로세스에게 주어진 메모리는 공유가 가능하지 않으면 프로세스 안에 있는 스레드들은 자원과 메모리를 공유한다.\n정의 스레드와-프로세스\n특이점  Process는 서로 소통하지 않지만 IPC(Inter Process Communication) 라는게 존재한다 JAVA에는 프로세스라는게 존재하지 않는다, Java.exe 자체가 프로세스다. 프로세스라는 것은 프로그램과 같은 개념으로 볼 수 있다. 동시다발적으로 요청을 처리하기 위해 스레드를 사용할 수 있다.  이해도 향상을 위한 그림 코드 예시 public class MyThread extends Thread { public void run(){ System.out.println(\u0026#34;MyThread running\u0026#34;); } } MyThread myThread = new MyThread(); myTread.start(); OR\nThread thread = new Thread(){ public void run(){ System.out.println(\u0026#34;Thread Running\u0026#34;); } } thread.start(); Thread 스타트로 소환된 thread에서 run이 실행될때 \u0026ldquo;Thread Running\u0026quot;이 출력됨\n","permalink":"https://ajdeve.github.io/post/thread-vs.-process/","summary":"Thread VS. Process Thread VS. Process 프로세스는 독립적이며 프로세스 안에는 스레드가 있다. 프로세스에게 주어진 메모리는 공유가 가능하지 않으면 프로세스 안에 있는 스레드들은 자원과 메모리를 공유한다.\n정의 스레드와-프로세스\n특이점  Process는 서로 소통하지 않지만 IPC(Inter Process Communication) 라는게 존재한다 JAVA에는 프로세스라는게 존재하지 않는다, Java.exe 자체가 프로세스다. 프로세스라는 것은 프로그램과 같은 개념으로 볼 수 있다. 동시다발적으로 요청을 처리하기 위해 스레드를 사용할 수 있다.  이해도 향상을 위한 그림 코드 예시 public class MyThread extends Thread { public void run(){ System.","title":"Thread VS. Process"},{"content":"Web 기본 Web 개발 기술   http 프로토콜 기반의 지원 기술\n  client단 개발 기술\n 화면 구성 html: 구조  서버에 전송하고자 하는 입력 양식 (input from)   css: 보기 좋게 꾸미는 언어 Java script: 브라우저 화면을 동적 처리를 위한 언어  모든 서버단 언어와 소통이 가능 화면단 처리 언어 Java와 non-java와 소통 가능      server단 개발 기술 (back)\n Java 기반: Servle \u0026amp; JSP  servlet  java 기반의 웹 처리 스펙 controller   JSP  Java 코드 보다는 jsp 자체 tag + html tag + css + java script 위주의 화면단 처리 스펙 Java 코드 보다는 jsp 자체 tag 위주의 화면단 처리 스펙 Java의 데이터값을 브라우저 화면에 출력하게 하는 기술 화면 처리 언어 html과 가장 큰 차이점  html은 자바 코드 활용 불가       php, asp, django\u0026hellip;  python 기반의 분석      front + back = full stack\n  Java 는 Servlet과 소통한다.\n","permalink":"https://ajdeve.github.io/post/web01/","summary":"Web 기본 Web 개발 기술   http 프로토콜 기반의 지원 기술\n  client단 개발 기술\n 화면 구성 html: 구조  서버에 전송하고자 하는 입력 양식 (input from)   css: 보기 좋게 꾸미는 언어 Java script: 브라우저 화면을 동적 처리를 위한 언어  모든 서버단 언어와 소통이 가능 화면단 처리 언어 Java와 non-java와 소통 가능      server단 개발 기술 (back)\n Java 기반: Servle \u0026amp; JSP  servlet  java 기반의 웹 처리 스펙 controller   JSP  Java 코드 보다는 jsp 자체 tag + html tag + css + java script 위주의 화면단 처리 스펙 Java 코드 보다는 jsp 자체 tag 위주의 화면단 처리 스펙 Java의 데이터값을 브라우저 화면에 출력하게 하는 기술 화면 처리 언어 html과 가장 큰 차이점  html은 자바 코드 활용 불가       php, asp, django\u0026hellip;  python 기반의 분석      front + back = full stack","title":"Web Beginner Series 1"},{"content":"JAVA Level 1. 기초 메서드 1. System.out 활용 메서드 - 출력 public static void main(String[] args) { System.out.print(\u0026#34;Hello World\u0026#34;); } - String 출력 public static void main(String[] args) { String h = \u0026#34;Hello World\u0026#34;; System.out.print(h); } - String + 출력 public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34; \u0026#34;; String c = \u0026#34;World\u0026#34;; System.out.print(a + b + c); } - String 출력 +, ++, if, == public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34; \u0026#34;; String c = \u0026#34;World\u0026#34;; int i = 1; i++; if (i == 2) { System.out.println(a + b + c); }else { System.out.println(b); } } 2. charAt 활용 메서드 - 출력 charAt, for, ++, String public static void main(String[] args) { String java = \u0026#34;Hello World!\u0026#34;; for(int i = 0; i \u0026lt; java.length(); i++) { char character = java.charAt(i); System.out.print(character); } 3. class 활용 메서드 - Class +, new class A{ String a = \u0026#34;Hello world!\u0026#34;; } public class ExampleSet { public static void main(String[] args) { A a = new A(); System.out.println(a.a); } } - Class +, new, + class B{ String b = \u0026#34;Hello \u0026#34;; } class C{ String c = \u0026#34;world!\u0026#34;; } public class ExampleSet { public static void main(String[] args) { B b = new B(); C c = new C(); System.out.println(b.b + c.c); } } - Class +, Array, new, + class D { String[] d = { \u0026#34;Hello \u0026#34;, \u0026#34;world!\u0026#34; }; } public class ExampleSet { public static void main(String[] args) { D d = new D(); System.out.println(d.d[0] + d.d[1]); } } ","permalink":"https://ajdeve.github.io/post/java1/","summary":"JAVA Level 1. 기초 메서드 1. System.out 활용 메서드 - 출력 public static void main(String[] args) { System.out.print(\u0026#34;Hello World\u0026#34;); } - String 출력 public static void main(String[] args) { String h = \u0026#34;Hello World\u0026#34;; System.out.print(h); } - String + 출력 public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34; \u0026#34;; String c = \u0026#34;World\u0026#34;; System.out.print(a + b + c); } - String 출력 +, ++, if, == public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34; \u0026#34;; String c = \u0026#34;World\u0026#34;; int i = 1; i++; if (i == 2) { System.","title":"JAVA Method Examples"},{"content":"JDBC 환경세팅 CASE: 하나의 Team에는 한명의 Member가 있는 상황 @OneToOne   eclipse에서 new java project 생성\n  마우스 오른쪽 클릭 → configure → maven project\n  마우스 오른쪽 클릭 → configure → JPA project\n  pom.xml setup\n  Dependency \u0026amp; Repository setup\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.persistence-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.2.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.jslsolucoes\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ojdbc6\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;11.2.0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.platform\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-platform-runner\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-engine\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-params\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- @Slf4j 사용을 위한 library 설정 \u0026amp; log4j.properties 필요 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-log4j12\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;oracle\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;ORACLE JDBC Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.atlassian.com/3rdparty/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt;     log4j properties 파일을 src 안으로 복사하고 붙여넣는다.\n  log4j.properties\n# Set root category priority to INFO and its only appender to CONSOLE. log4j.rootCategory= INFO, CONSOLE, daily \\u200B # CONSOLE is set to be a ConsoleAppender using a PatternLayout. log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout log4j.appender.CONSOLE.layout.ConversionPattern=- [%-p] %m%n \\u200B log4j.appender.daily=org.apache.log4j.DailyRollingFileAppender log4j.appender.daily.File=C:\\\\ITStudy\\\\88.log\\\\fiveguys.log #C:\\\\ITStudy\\\\88.log log4j.appender.daily.DatePattern='.'yyyy-MM-dd log4j.appender.daily.layout=org.apache.log4j.PatternLayout log4j.appender.daily.layout.ConversionPattern=- [%-p] %d{dd-MM-yyyy HH:mm:ss} %F %m%n     META INF 안의 persistence.xml 파일 설정\n  persistence.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;persistence version=\u0026quot;2.1\u0026quot; xmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\u0026quot;\u0026gt; \u0026lt;persistence-unit name=\u0026quot;oracleDBUse\u0026quot;\u0026gt; \u0026lt;class\u0026gt;entity2.Member\u0026lt;/class\u0026gt; \u0026lt;class\u0026gt;entity2.Team\u0026lt;/class\u0026gt; \u0026lt;!-- \u0026lt;class\u0026gt;entity.Member\u0026lt;/class\u0026gt; \u0026lt;class\u0026gt;entity.Team\u0026lt;/class\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;class\u0026gt;step01.entity.Dept01\u0026lt;/class\u0026gt; --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:xe\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;SCOTT\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;TIGER\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.OracleDialect\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.id.new_generator_mappings\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;none\u0026quot; /\u0026gt; --\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/persistence-unit\u0026gt; \u0026lt;/persistence\u0026gt; persistence.xml 파일에서 db 접속 정보 설정 tag 확인해서 아이디 패스워드 확인\n    Entity, Test 와 Util java class를 만들어서 테스트 환경 조성\n  Entity 주의사항\n  @Entity 애노테이션 선언\n  persistence.xml 에 등록 (persistence file 눌러 JPA synchronize 하여 class 연동하기)\n  각 컬럼별 이름, 사이즈 조절\n  String 타입은 length로 사이즈 조절\n  Number 타입읁 BigDecimal, precision으로 조절\n  @Column\n  @GeneratedValue(strategy=GenerationType.SEQUENCE\n//콘솔창에 뜨는 해당 사항 drop sequence hibernate_sequence Hibernate: create sequence hibernate_sequence start with 1 increment by 1 3.@Column(length=20, nullable=false)     Team (Parent Class)\n@NoArgsConstructor @AllArgsConstructor @Builder @Getter @Setter @Entity @SequenceGenerator(name=\u0026#34;TEAM_ID_SEQ\u0026#34;, sequenceName = \u0026#34;TEAM_SEQ\u0026#34;, initialValue = 1, allocationSize = 50) public class Team { @Id @GeneratedValue (strategy=GenerationType.SEQUENCE, generator=\u0026#34;TEAM_ID_SEQ\u0026#34;) @Column (name=\u0026#34;team_id\u0026#34;) private Long teamId; @Column (name = \u0026#34;team_name\u0026#34;, length = 20) private String teamName; }   Member (Child Class)\n@NoArgsConstructor @AllArgsConstructor @Builder @Getter @Setter @Entity @SequenceGenerator(name=\u0026#34;MEMBER_ID_SEQ\u0026#34;, sequenceName = \u0026#34;MEMBER_ID\u0026#34;, initialValue = 1, allocationSize = 50) public class Member { @Id @GeneratedValue (strategy=GenerationType.SEQUENCE, generator=\u0026#34;MEMBER_ID_SEQ\u0026#34;) //sequence  @Column (name=\u0026#34;member_id\u0026#34;) private Long memberId; @Column (name = \u0026#34;member_name\u0026#34;, length = 20) private String memberName; @Column (name=\u0026#34;member_age\u0026#34;) private Integer memberAge; @OneToOne @JoinColumn (name = \u0026#34;team_id\u0026#34;, referencedColumnName = \u0026#34;team_id\u0026#34;) private Team teamId; }     Test\nEntityManager의 개별 메소드로 crud 하는 실행 클래스\npublic class RunningTest { //step02  @Test public void runningTest() { EntityManager em = PublicCommon.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try { Team t1 = Team.builder().teamName(\u0026#34;team A\u0026#34;).build(); em.persist(t1); Team t2 = Team.builder().teamName(\u0026#34;team B\u0026#34;).build(); em.persist(t2); // member 객체 생성 후 insert 시도할 경우 member의 teamid는 이미 존재하는 team 이어야함  Member m1 = Member.builder().memberName(\u0026#34;유재석\u0026#34;).teamId(t1).memberAge(50).build(); em.persist(m1); Member m2 = Member.builder().memberName(\u0026#34;강재석\u0026#34;).teamId(t2).memberAge(40).build(); em.persist(m2); tx.commit(); } catch(Exception e) { e.printStackTrace(); } finally { em.close(); } }   Util\n실행 클래스에 활용될 Util 클래스 개발\n EntiyManagerFactory EntityManager  package util; import javax.persistence.EntityManager; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class PublicCommon { //db driver처럼 한번만 메모리 생성 후 저장 및 쭉 재사용  private static EntityManagerFactory emf; //멤버변수 초기화  static { emf = Persistence.createEntityManagerFactory(\u0026#34;oracleDBUse\u0026#34;); } //CRUD 로직별 생성 및 client는 공유 금지  //EntityManager 반환  public static EntityManager getEntityManager() { return emf.createEntityManager(); } //자원반환 em.close()는 매번 상황에 맡겨서 하기  public static void close(EntityManager em) { emf.close(); } }     ","permalink":"https://ajdeve.github.io/post/jdbc1/","summary":"JDBC 환경세팅 CASE: 하나의 Team에는 한명의 Member가 있는 상황 @OneToOne   eclipse에서 new java project 생성\n  마우스 오른쪽 클릭 → configure → maven project\n  마우스 오른쪽 클릭 → configure → JPA project\n  pom.xml setup\n  Dependency \u0026amp; Repository setup\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.persistence-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.2.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.jslsolucoes\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ojdbc6\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;11.2.0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.platform\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-platform-runner\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.","title":"JDBC 환경세팅"},{"content":"JDBC\u0026amp;JPA JDBC, JPA/Hibernate를 사용할때 제일 헷갈리는 부분을 아래와 같이 정리했다.\nflush() : DB에 실제 쿼리를 날려 execute하는 기능이며 commit이 아니기에 DB에 반영이 되지 않는다.\nclear() : 영속성 컨텍스트에 저장한 데이터를 지워버린다.\ncommit() : DB에 저장,수정,삭제를 반영한다.\nrollback:() : DB에 저장하지 않고 영속성 컨텍스트 데이터를 날린다.\n","permalink":"https://ajdeve.github.io/post/jdbc0/","summary":"JDBC\u0026amp;JPA JDBC, JPA/Hibernate를 사용할때 제일 헷갈리는 부분을 아래와 같이 정리했다.\nflush() : DB에 실제 쿼리를 날려 execute하는 기능이며 commit이 아니기에 DB에 반영이 되지 않는다.\nclear() : 영속성 컨텍스트에 저장한 데이터를 지워버린다.\ncommit() : DB에 저장,수정,삭제를 반영한다.\nrollback:() : DB에 저장하지 않고 영속성 컨텍스트 데이터를 날린다.","title":"JDBC\u0026JPA"},{"content":"Spring Framework  Rod Johnson이 2003년 개발한 Spring Framework는 JavaEE 앱을 쉽게 만들게 한다. 객체를 한곳에서 모아서 관리하며 표준화와 정형화된 코드를 짤 수 있게 하는 프레임워크!\nSpring Framework + Business Logic (컨텐츠) = Application\n Spring Framework란?  자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크로서 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량급 애플리케이션 프레임워크 Spirng Framework는 경량 컨테이너로 자바 객체를 담고 직접 관리한다. 객체의 생성 및 소멸 그리고 라이프 사이클을관리하며 언제든 Spring 컨테이너로 부터 필요한 객체를 가져와 사용할 수 있다. 우리나라의 공공기관의 웹 서비스 개발 시 사용을 권장하고 있는 전자정부 표준프레임워크의 기반 기술로서 쓰이고 있다. 표준화가 되어있는 코드를 통해서 어떤 개발자가 봐도 해결할 수 있게 한다. 객체를 한곳에서 모아서 관리하며 표준화와 정형화된 코드를 짤 수 있게 하는 프레임워크  주요 특징 1. 경량 컨테이너(크기와 부하의 측면)로서 자바 객체를 직접 관리 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다. 돈도 적게 들어감.\n2. 제어 역행 (IoC : Inversion of Control) 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어 필요에 따라 스프링에서 사용자의 코드를 호출한다.\nSpring은 IOC (Inversion of Control 제어의 역전) 기반의 Framework이다. 이전의 프로그램 객체 결정 및 생성 -\u0026gt; 의존성 객체 생성 -\u0026gt; 객채 내의 메소드 호출 하는 작업을 반복했다. 이는 각 객체들이 프로그램의 흐름을 결정하고 각 객체를 구성하는 작업에 직접적으로 참여한 것이다.\n즉, 모든 작업을 사용자가 제어하는 구조인 것이였는데 IOC에서는 객체는 자기가 사용할 객체를 선택하거나 생성하지 않는다. 또한 자신이 어디서 만들어지고 어떻게 사용되는지 또한 모른다. 자신의 모든 권한을 다른 대상에 위임함으로 써 제어권한을 위임받은 특별한 객체에 의해 결정되고 만들어진다.\n즉, 제어의 흐름을 사용자가 컨트롤 하지 않고 위임한 특별한 객체에 모든 것을 맡기는 구조\nSpring은 IOC 컨테이너이다. 빈 객체의 생성(new), 빈 객체간 관계 설정(set), 빈 객체 관리(singleton등) 가 컨테이너 주요기능 으로 Spring Container가 관리한다.\nIOC의 구성요소 DL: Dependency Lookup 의존성 검색: 컨테이너에서는 객체들을 관리하기 위해 별도의 저장소에 빈을 저장하는데 저장소에 저장되어 있는 개발자들이 컨테이너에서 제공하는 API 를 이용하여 사용하고자 하는 빈 을 검색하는 방법\nDI: Dependency Injection (제일 중요한 컨셉중 하나) 의존성 주입: 의존성 주입이란 객체가 서로 의존하는 관계가 되게 의존성을 주입하는 것이며 객체지향 프로그램에서 의존성 이란 하나의 객체가 어떠한 다른 객체를 사용하고 있음을 의미한다. 그리고 객체는 의존하고 있는 객체를 코드 상에서 직접 생성하고나 검색할 필요가 없다.\nIOC에서의 DI란 바로 각 클래스 사이에 필요로 하는 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해 주는 것이다.\n출처\n3. 의존성 주입 (DI : Dependency Injection)  각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.  원래 코드\npublic class Store { private Item item; public Store() { item = new ItemImpl1(); } } DI 코드\npublic class Store { private Item item; public Store(Item item) { this.item = item; } } https://www.javaguides.net/2018/06/guide-to-dependency-injection-in-spring.html\n4. 관점지향 프로그래밍 (AOP : Aspect-Oriented Programming)  트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.  Spring Framework란 AOP (Aspect Oriented Programming) 관점 지향 프로그래밍이다. 대부분은 객체 지향 프로그래밍을 지향하는 개발 프로세스인데, 중복된 코드들이 많아지고 가독성, 확장성, 유지보수성을 떨어뜨린다. AOP는 이 단점을 보완한다.\nSpring은 자체적으로 AOP를 지원하고 있기 때문에 트랜잭션이나 로깅, 보안과 같이 여러 비즈니스 모듈에서 공통적으로 필요로 하는 공통관심 사항을 핵심 로직과 분리시켜 각 모듈에 적용할 수 있음\n여러 오브젝트에 공통되는 코드를 모듈화하여 무분별하게 중복되는 코드를 한 곳에 모아 중복 되는 코드를 제거 할 수 있어지고 공통기능을 한 곳에 보관함으로써 공통 기능 하나의 수정으로 모든 핵심기능들의 공통기능을 수정 할 수 있어 효율적인 유지보수가 가능하며 재활용성이 극대화 될 수 있다.\n물론 AOP로 만들 수 있는 기능은 OOP로 구현 할 수 있는 기능이지만 Spring에서는 AOP를 편리하게 사용 할 수 있도록 이를 지원하고 있다.\n추가적으로 AOP를 공부하려면 클릭\n5.영속성과 관련된 다양한 API 지원 및 연동 지원  iBatis, myBatis나 Hibernate 등 완성도가 높은 데이터베이스처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.  6. 트랜잭션 관리 프레임워크  추상화된 트랜잭션 관리를 지원하며 설정파일(xml, java, property 등)을 이용한 선언적인 방식 및 프로그래밍을 통한 방식을 모두 지원한다.  7. 모델-뷰-컨트롤러 (MVC) 패턴   웹 프로그램밍 개발 시 거의 표준적인 방식인 \u0026ldquo;Spring MVC\u0026rdquo; 라 불리는 모델-뷰-컨트롤러(MVC) 패턴을 사용한다.\n  DispatcherServlet이 Controller 역할을 담당하여 각종 요청을 적절한 서비스에 분산시켜주며 이를 각 서비스들이 처리를 하여 결과를 생성하고 그 결과는 다양한 형식의 View 서비스들로 화면에 표시될 수 있다. (추후에 Web에 들어가게 되면 이해가 될듯함)\n  Spring Framework의 MVC (Model2)  MVC란 (Model View Controller) 구조로 사용자 인터페이스와 비지니스 로직을 분리하여 개발 하는 것 MVC에서는 Model1과 Model2로 나누어져 있으며 일반적인 MVC는 Model2를 지칭  MVC1 MVC2 MVC1과는 다르게 Controller, View가 분리되어 있다.\nSpring MVC Pattern 스프링에서는 유저의 요청을 받는 DispathcerServlet이 핵심이며 이것이 Front Controller의 역할을 맡는다. Front Controller(프런트 컨트롤러)란, 우선적으로 유저(클라이언트)의 모든 요청을 받고, 그 요청을 분석하여 세부 컨트롤러들에게 필요한 작업을 나눠주게 된다.\nModel\n 데이터처리를 담당하는 부분 Serivce영역과 DAO영역으로 나누어지게 되고 여기서 중요한 것은 Service 부분은 불필요하게 HTTP통신을 하지 않아야하고 request나 response와 같은 객체를 매개변수로 받아선 안된다. 또한 Model 부분의 Service는 view에 종속적인 코드가 없어야 하고 View 부분이 변경되더라도 Service 부분은 그대로 재사용 할 수 있어야 한다. Model에서는 View와 Controller 어떠한 정보도 가지고 있어서는 안된다.  View\n 사용자 Interface를 담당하며 사용자에게 보여지는 부분 View는 Controller를 통해 모델에 데이터에 대한 시각화를 담당하며 View는 자신이 요청을 보낼 Controller의 정보만 알고 있어야 하는 것이 핵심 Model이 가지고 있는 정보를 저장해서는 안되며 Model, Controller에 구성 요소를 알아서는 안됨  Controller\n Controller에서는 View에 받은 요청을 가공하여 Model(Service 영역)에 이를 전달한다. 또한 Model로 부터 받은 결과를 View로 넘겨주는 역할을 한다. Controller에서는 모든 요청 에러와 모델 에러를 처리하며 View와 Controller에 정보를 알고 있어야한다. Model과 View의 정보에 대해 알고 있어야한다.  이렇게 Model, View, Controller를 나누는 이유는 소스를 분리함으로서 각 소스의 목적이 명확해 지고 유지보수하는데 있어서 용이하기 때문이다. Model의 Service영역은 자신을 어떠한 Controller가 호출하든 상관없이 정해진 매개변수만 받는다면 자신의 비즈니스 로직을 처리할 수 있어야한다.\n즉, 모듈화를 통해 어디서든 재사용이 가능하여야 한다는 뜻이다.\n이말은 View의 정보가 달라지더라도 Controller에서 Service에 넘겨줄 매개변수 데이터 가공만 처리하면 되기 때문에 유지보수 비용을 절감 할 수 있는 효과가 있다. 또한 Service영역의 재사용이 용이하기 때문에 확장성 부분에서도 큰 효과를 볼 수 있는 장점이있다.\n8. 배치 프레임워크  스프링은 특정 시간대에 실행하거나 대용량의 자료를 처리하는데 쓰이는 일괄 처리(Batch Processing)을 지원하는 배치 프레임워크를 제공한다. 기본적으로 스프링 배치는 Quartz 기반으로 동작한다. Quartz: 자바 스케줄링 오픈소즈 프레임워크 , Quartz is an open source job-scheduling framework written entirely in Java and designed for use in both J2SE and J2EE applications. https://www.baeldung.com/quartz  9. POJO Spring Framework의 POJO란? POJO: Plain Old Java Object POJO란 특정 규약 및 환경에 종속적이지 않은 평범한 일반 자바 클래스 의미\nPOJO의 조건\n  특정규약에 종속되지 않는다.\nPOJO는 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 한다. EJB와 같이 특정 규약을 따라 비즈니스 컴포넌트를 만들어야 하는 경우는 POJO가 아니다. 특정 클래스를 상속해서 만들어야 하는 규약이 있는 경우도 마찬가지다.\n  특정 환경에 종속되지 않는다.\n특정 환경에 종속적이어야만 동작하는 오브젝트도 POJO라고 할 수 없다. POJO는 환경에 독립적이어야 한다.\n  POJO의 장점\n  특정기술과 환경에 종속되지 않은 오브젝트는 그만큼 깔끔한 코드가 될 수 있다.\n  POJO로 개발된 코드는 자동화된 테스트에 매우 유리하다.\n  객체지향적인 설계를 자유롭게 적용할 수 있다.\n  Spring Framework 에서는 POJO을 지원한다.\n Spring 개발에 POJO 클래스를 활용할 수 있다는건 특정 구현 기술에 종속적이지 않다는 의미 개발 후의 테스트시에도 DB와 특정 서버 없이도 테스트를 할 수 있기 때문에 개발이 빨라진다는 장점이 있음 EJB와 다르게 기본 자바 클래스 코드 그대로 사용가능함  10. 트랜잭션 처리를 위한 일관된 방법 제공  벤더사에 상관없이 처리를 일관된 방법을 사용하여 할 수 있게 한다. JDBC API 및 JPA를 사용하거나 컨테이너가 제공하는 트랜잭션을 사용하든, 설정 파일을 통해 트랜잭션 관련 정보를 관리하기 때문에 특정 트랜잭션 구현 방법에 상관없이 동일 한 코드를 여러 환경에서 사용 가능  즉 공통 부분의 소스 코딩이 용이하며 확장성도 매우 좋다\n출처\n구조 Spring Core  Spring Container를 의미한다. core라는 말 그대로 Container는 Spring Framework의 핵심이며 그중 핵심은 Bean Factory Container이다. 그 이유는 바로 Bean Factory는 IOC패턴을 적용하여 객체 구성 부터 의존성 처리까지 모든 일을 처리하는 역할을 하고 있기 때문이다. Spring 프레임워크의 근간이 되는요소. IoC(또는 DI) 기능을 지원하는 영역을 담당. BeanFactory를 기반으로 Bean 클래스들을 제어할 수 있는 기능을 지원 One main between BeanFactory and ApplicationContext is that BeanFactory only instantiates bean when we call getBean() method while ApplicationContext instantiates singleton bean when the container is started, It doesn\u0026rsquo;t wait for getBean() method to be called.  Spring Context  Spring context는 Spring Framework의 context 정보들을 제공하는 설정 파일이다. Spring Context에는 JNDI, EJB, Validation, Scheduiling, Internaliztaion 등 엔터프라이즈 서비스들을 포함 Spring Core 바로 위에 있으면서 Spring Core에서 지원하는 기능외에 추가적인 기능들과 좀 더 쉬운 개발이 가능하도록 지원 또한 JNDI, EJB등을 위한 Adaptor들을 포함  Spring AOP  Spring AOP module은 Spring Framework에서 관점지향 프로그래밍을 할 수 있고 AOP를 적용 할수 있게 도와주는 Module이다. Spring 프레임워크에 Aspect Oriented Programming을 지원하는 기능이다.  Spring DAO  DAO란 Data Access Object의 약자로 Database Data에 접근하는 객체이다. Spring JDBC DAO는 추상 레이어를 지원함으로써 코딩이나 예외처리 하는 부분을 간편화 시켜 일관된 방법으로 코드를 짤 수 있게 도와준다. 지금까지 우리들이 일반적으로 많이 사용해왔던 JDBC 기반하의 DAO개발을 좀 더 쉽고, 일관된 방법으로 개발하는 것이 가능하도록 지원 Spring DAO를 이용할 경우 지금까지 개발하던 DAO보다 적은 코드와 쉬운 방법으로 DAO를 개발하는 것이 가능  Code 예시 DAO public abstract class AbstractJpaDAO\u0026lt; T extends Serializable \u0026gt; { private Class\u0026lt; T \u0026gt; clazz; @PersistenceContext EntityManager entityManager; public final void setClazz( Class\u0026lt; T \u0026gt; clazzToSet ){ this.clazz = clazzToSet; } public T findOne( long id ){ return entityManager.find( clazz, id ); } public List\u0026lt; T \u0026gt; findAll(){ return entityManager.createQuery( \u0026#34;from \u0026#34; + clazz.getName() ) .getResultList(); } public void create( T entity ){ entityManager.persist( entity ); } public T update( T entity ){ return entityManager.merge( entity ); } public void delete( T entity ){ entityManager.remove( entity ); } public void deleteById( long entityId ){ T entity = findOne( entityId ); delete( entity ); } } The persistence post processor is either created explicitly by defining it in the configuration or automatically, by defining context:annotation-config or context:component-scan in the namespace config.\nAlso, note that the entity Class is passed in the constructor to be used in the generic operations:\n@Repository public class FooDAO extends AbstractJPADAO\u0026lt; Foo \u0026gt; implements IFooDAO{ public FooDAO(){ setClazz(Foo.class ); } } Spring ORM  ORM이란 Object relational mapping의 약자로 간단하게 객체와의 관계 설정을 하는 것이다. Spring에서는 Ibatis, Hibernate, JDO 등 인기있는 객체 관계형 도구(OR도구)를 사용 할 수 있도록 지원합니다 Object Relation Mapping 프레임워크인 Hibernate, IBatis, JDO와의 결합을 지원하기 위한 기능 Spring ORM을 이용할 경우 Hibernate, IBatis, JDO 프레임워크와 쉽게 통합하는 것이 가능  코드 예시: https://www.journaldev.com/7655/spring-orm-example-jpa-hibernate-transaction\nSpring Web  Spirng에서 Web context module은 Application module에 내장되어 있고 Web기반의 응용프로그램에 대한 Context를 제공하여 일반적인 Web Application 개발에 필요한 기본적인 기능을 지원한다. 그로인해 Jakarta Structs 와의 통합을 지원한다.  Spring MVC  Spring에서는 MVC에서는 Model2 구조로 Aplication을 만들 수 있도록 지원한다. MVC (Model-View-Controller) 프레임 워크는 웹 응용 프로그램을 작성하기위한 완전한 기능을 갖춘 MVC를 구현한다. MVC 프레임 워크는 전략 인터페이스를 통해 고급 구성 가능하며 JSP, Velocity, Tiles, iText 및 POI를 포함한 수많은 뷰 기술을 지원하고 있다.  https://goddaehee.tistory.com/154?category=173020\n[Spring] Filter, Interceptor, AOP 차이 및 정리+ https://goddaehee.tistory.com/154?category=173020\nSpring Annotation정리 https://velog.io/@gillog/Spring-Annotation-%EC%A0%95%EB%A6%AC\n","permalink":"https://ajdeve.github.io/post/spring-framework/","summary":"Spring Framework  Rod Johnson이 2003년 개발한 Spring Framework는 JavaEE 앱을 쉽게 만들게 한다. 객체를 한곳에서 모아서 관리하며 표준화와 정형화된 코드를 짤 수 있게 하는 프레임워크!\nSpring Framework + Business Logic (컨텐츠) = Application\n Spring Framework란?  자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크로서 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량급 애플리케이션 프레임워크 Spirng Framework는 경량 컨테이너로 자바 객체를 담고 직접 관리한다. 객체의 생성 및 소멸 그리고 라이프 사이클을관리하며 언제든 Spring 컨테이너로 부터 필요한 객체를 가져와 사용할 수 있다.","title":"Spring Framework"}]