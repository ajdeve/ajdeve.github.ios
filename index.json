[{"content":"DOM (돔) 정의  Document Object Model 그리고 문서 객체 모델이며 HTML 및 XML 문서를 위한 API이다. 이 DOM이란 트리 구조로 되어있는 객체 모델로써, Javascript가 getElementbyid()를 같은 함수를 이용하여 HTML문서의 각 요소(li, head같은 태그들)들을 접근하고 사용할 수 있도록 하는 객체 모델이다. 브라우저마다 DOM을 구현하는 방식은 다르기에 DOM이라는 것이 구체적으로 정해저 있는 언어나 모델과 같은 것은 아니다. 다만 웹페이지를 객체로 표현한 모델을 의미할 뿐이다.  DOM 의 트리구조 예시 브라우저가 돔을 이용해서 화면을 렌더링 하는 방법 예시 첫째, 브라우저는 html태그를 파싱 하여 돔 트리를 구성한다. 동시에 브라우저는 스타일시트에서 css를 파싱 하여 스타일 규칙들을 만들어낸다. 둘째, 위에서 언급한 돔 트리와 스타일 규칙 두 가지가 합쳐져서 렌더 트리를 만들어낸다.\nVIRTUAL DOM (가상 돔) 정의  A virtual DOM is a lightweight JavaScript representation of the DOM used in declarative web frameworks such as React, Vue.js, and Elm. Updating the virtual DOM is comparatively faster than updating the actual DOM, since nothing has to be rendered onto the screen. - Wikipedia -\n가상돔이란 돔을 가볍게 만든 자바스크립트 표현이라고 할 수 있고 주로 React, Vue.js 그리고 Elm에 사용된다. 가상돔은 실제로 스크린에 랜더링을 하는것이 아니기에 돔을 직접 업데이트 하는것보다 상대적으로 빠르다.\n 필요성및 차이점 돔의 문제  SPA (Single Page Application)의 출현으로 가상 돔이 매우 필요해졌다.\n DOM은 트리구조로 되어있어서 이해하기 쉽다는 장점은 있으나, 이 구조는 거대해 질때 속도가 느려지고, DOM 업데이트에 잦은 오류를 야기한다. DOM을 분석하는데에도 힘든 단점이 있다.\n그런데 최근 모던 웹은 SPA(Single Page Application) 을 사용한다. 하나의 웹 페이지를 어플리케이션 처럼 구성하는 SPA에서는 HTML 문서 자체가 하나이며, Application이라 칭 할 만큼 여러 동적인 기능(실시간 기능)들이 들어가기 때문에 안그래도 리소스가 모두 합쳐진 HTML 문서를 지속적으로 재 렌더링 해주어야 하는 문제점이 발생하게 되었다.\n기존에는 화면의 변경사항을 돔을 직접 조작하여 브라우저에 반영하였다. 하지만, 이 방법의 가장 큰 단점은 돔 트리가 수정될 때마다 렌더 트리가 계속해서 실시간으로 갱신된다는 점이었다. 즉, 화면에서 10개의 수정사항이 발생하면 수정할 때마다 새로운 랜더 트리가 10번 수정되면서 새롭게 만들어지게 되는 것이다.\n그래서 가상 돔이 출현   가상돔(Virtual DOM)은 실제 DOM 문서를 추상화한 개념으로, 변화가 많은 View를 실제 DOM에서 직접 처리하는 방식이 아닌 Virtual Dom과 메모리에서 미리 처리하고 저장한 후 실제 DOM과 동기화 하는 프로그래밍 개념입니다.\n  해당 DOM을 컴포넌트 단위로 쪼개어 HTML 컴포넌트 조립품 처럼 다루는 개념이다. 이 조립품들이 VirtualDOM이라 할 수 있다.\n  Vue, React는 가상 돔 방식을 채택했다.\n     돔 가상돔     업데이트가 느리다. 업데이트가 빠르다.   HTML을 직접적으로 업데이트 한다. HTML을 직접적으로 업데이트 하지 않는다.   새로운 element가 업데이트 된 경우 새로운 DOM을 생성한다. 새로운 element가 업데이트 된 경우 새로운 가상돔 생성한 후 이전 돔과 비교하여 차이를 계산 이후 돔을 업데이트한다.   메모리 낭비가 심하다. 메모리 낭비가 덜하다.    *업데이트가 빠른것은 가상돔이 돔보다 빠르다는 표현과는 다르다. VDOM의 주목적은 DOM의 직접적 변화의 수를 줄이는데 있고 이 변화가 느린것이다.\n아래와 같은 코드 돔은 브라우저가 핸들하여 생성한다.\n\u0026lt;ul class=\u0026#34;fruits\u0026#34;\u0026gt; \u0026lt;li\u0026gt;Apple\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Orange\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Banana\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Virtual DOM 식으로 표현된 코드 React, Vue 등의 모던 프레임워크가 실제 돔과 비슷한 가상돔을 메모리에 생성한다.\n// Virtual DOM representation { type: \u0026#34;ul\u0026#34;, props: { \u0026#34;class\u0026#34;: \u0026#34;fruits\u0026#34; }, children: [ { type: \u0026#34;li\u0026#34;, props: null, children: [ \u0026#34;Apple\u0026#34; ] }, { type: \u0026#34;li\u0026#34;, props: null, children: [ \u0026#34;Orange\u0026#34; ] }, { type: \u0026#34;li\u0026#34;, props: null, children: [ \u0026#34;Banana\u0026#34; ] } ] } 출처\n가상돔의 Three Steps   어떠한 데이터의 변화가 일어났을때, 전체 UI가 가상 돔에서 재 랜더링이 된다.\n  이전 돔과 새로운 가상돔의 차이가 계산된다.   계산이 끝난 후, 돔은 변경된 부분만을 변화시킨다.   REACT/Vue.js/Angular/Elm 가 사용하는 가상 돔 첫 번째로 가상 돔은 리액트에서 나온 개념이 아니다.\n하지만 리액트는 무료로 이 개념을 사용하고 사용자들에게 제공한다. 퍼포먼스와 메모리 관리가 효율적으로 가능하게 되었다. 가상 돔을 활용하면 이러한 불필요한 렌더링 횟수를 줄일 수 있다. 가상 돔을 활용한 대표적인 프런트 앤드 프레임워크가 리액트, 뷰, 앵귤러이다. 이러한 프레임워크들은 화면에 변화가 있을 때마다 실시간으로 돔 트리를 수정하지 않고 변경사항이 모두 반영된 가상 돔을 만들어낸다. 그 후 가상 돔을 이용해 한 번만 돔수정을 하게 되고 이는 한 번만 렌더 트리를 만들어내게 된다. 결과적으로 브라우저는 한번만 렌더링을 하게 됨으로써 불필요한 렌더링 횟수를 줄일 수 있게 되는 것이다.\n\u0026lt; 추가 링크 \u0026gt; https://bitsofco.de/understanding-the-virtual-dom/\n","permalink":"https://ajdeve.github.io/post/domvsvdom/","summary":"DOM (돔) 정의  Document Object Model 그리고 문서 객체 모델이며 HTML 및 XML 문서를 위한 API이다. 이 DOM이란 트리 구조로 되어있는 객체 모델로써, Javascript가 getElementbyid()를 같은 함수를 이용하여 HTML문서의 각 요소(li, head같은 태그들)들을 접근하고 사용할 수 있도록 하는 객체 모델이다. 브라우저마다 DOM을 구현하는 방식은 다르기에 DOM이라는 것이 구체적으로 정해저 있는 언어나 모델과 같은 것은 아니다. 다만 웹페이지를 객체로 표현한 모델을 의미할 뿐이다.  DOM 의 트리구조 예시 브라우저가 돔을 이용해서 화면을 렌더링 하는 방법 예시 첫째, 브라우저는 html태그를 파싱 하여 돔 트리를 구성한다.","title":"DOM vs. Virtual DOM"},{"content":"Servlet \u0026amp; JSP 정의 Servlet: 서블렛은 Java class로서 서버의 요청을 다루기 위해 쓰인다.\n 서블렛을 통해 사용자의 input을 모으거나, DB에서 레코드를 출력한다거나 dynamic web page들을 생성하거나 할 수 있다. 쉽게 말하면 \u0026ldquo;클라이언트의 요구를 받아 그에 대한 처리를 한 후, 결과를 되돌려주는 서버 모듈\u0026quot;이다. 서블릿은 JSP에서 컨텐츠와 비즈니스 로직을 분리한다. JSP가 텍스트 파일 구조인데 비해 서블릿은 자바 클래스 구조이다.  출처: https://ddo-o.tistory.com/77 [공순이의 블로그]\nServlet 돌아가는 과정 서블렛은 Servlet Container (서블렛 컨테이너)에게서 컨트롤된다. 서버가 요청을 받을때 서버가 요청을 서블렛 컨테이너에게 넘겨주고, 서블렛 컨테이너가 요청을 처리하기 위한 서블렛에게 전달한다.\n Client가 웹 서버에 요청을 보낸다. 서버가 요청을 받고 서블렛 컨테이너가 HttpServletRequest, HttpServletResponse 두 객체를 생성한다. 서블렛 컨테이너가 가 해당 담당하는 서블렛으로 요청을 보낸다. 서블렛이 요청을 process하고 응답을 생성한다. (컨테이너가 서블렛 service() 메소드를 호출해서 POST, GET여부에 따라 doGet() 또는 doPost()를 호출하여 동적인 페이지를 생성함, 서블렛이 웹 서버에 HttpServletResponse 객체에 응답을 보낸다. 서버가 응답을 client에게 다시 보내고 client 브라우저는 스크린에 출력한다. 그리고 HttpServletResponse \u0026amp; Request 객체를 소멸시킨다.  Servlet Life Cycle  서블렛 로딩: 서버가 시작할때 모든 서블렛을 로딩한다. 서블렛 시작: init() 메소드로 서블렛이 시작  public void init() throws ServletException { // Initialization code like set up database etc.... } 요청 처리: service() 메소드로 client의 요청을 처리하며 서블렛에게 client의 요청을 알린다.  public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { // ... } 서블렛을 종료: destroy() 메소드로 서블렛이 종료됨. 서블렛의 라이프 사이클에서 단 한번 실행됨  public void destroy() { // }  init()과 destroy() 메소드는 한번 실행됨  JSP: Java Server Page 정의: Java 언어를 기반으로 하는 Server Side 스크립트 언어\n 자바 서버 페이지는 서블렛과 같이 웹앱을 만들기위한 기술이며, JSTL등등 다양한 표현법을 사용해서 더 많은 기능을 구현할 수 있다. 서버쪽의 기술 JSP tag 는 JAVA 코드를 HTML 페이지에 넣을때 사용한다. HTML 코드에 Java 코드를 넣어 동적인 웹 페이지를 생성하는 웹 어플리케이션 도구 JSP는 JSP 컨테이너에 의해서 client 요청을 처리하기전에 servlet으로 변환된다. Servlet 기술의 확장 Servlet를 보완한 스크립트 방식 표준 Servlet의 모든 기능 + 추가적인 기능  JSP Life Cycle  JSP를 서블렛으로 변환한다. JSP 페이지를 컴파일한다. _jsp.java 가 class file_jsp.class로 변환된다. Object of generated servlet is created. _jspinit() 메소드가 컨테이너로 시작된다. _jspservice() 메소드가 컨테이너에 의해 요청을 처리한다. _jspDestroy() 메소드가 실행되어 컨테이너에 의해 종료된다.  Code Example   Declaration Tag :-메서드와 변수 모두 선언할 수 있다.\njava\r**Syntax:-** \u0026lt;%! Dec var %\u0026gt;\r**Example:-**\r\u0026lt;%! int var=10; %\u0026gt;\r\n  Java Scriplets :- 임의의 자바코드 대부분은 여기 가능하다. Method가 아닌 변수만 선언할 수 있다. java\r**Syntax:-** \u0026lt;% java code %\u0026gt;\r\n  JSP Expression :- String으로 변환되어 Servlet의 출력에 삽입된다. 끝에 \u0026ldquo;;\u0026rdquo; 세미콜론을 붙이지 않는다.\njava\r**Syntax:-** \u0026lt;%= expression %\u0026gt; **Example:-** \u0026lt;% num1 = num1+num2 %\u0026gt; \n  JAVA Comments :-주석달기 java\r**Syntax:-** \u0026lt;% -- JSP Comments %\u0026gt;\r\n  JAVA Comments :-주석달기 java\r**Syntax:-** \u0026lt;% -- JSP Comments %\u0026gt;\r\n  JAVA Directive : -JSP 페이지의 전체적인 구조에 영향을 미친다. 전체 구조에 대해 WAS에 지시를 내린다. 지시어에 들어가는 것: page, include, taglib java\r\u0026lt;%@ directive %\u0026gt;\r   page: page 지시어는 Container에 명령을 제공하는데 사용된다.\n\u0026lt;%@ page attribute = \u0026#34;value\u0026#34; %\u0026gt; include: include 지시어는 변환 단계에서 다른 외부 파일의 내용을 현재 JSP에 병합하도록 Container에 지시한다.\n\u0026lt;%@ include file = \u0026#34;relative_url\u0026#34; %\u0026gt; taglib: JSP API를 사용하면 HTML 또는 XML 태그처럼 보이는 사용자 정의 태그(custom tags)를 정의할 수 있다. tag library는 사용자가 정의한 동작을 구현한 사용자 정의(user-defined) 태그 집합이다.\n\u0026lt;%@ taglib uri = \u0026#34;uri\u0026#34; prefix = \u0026#34;prefixOfTag\u0026#34; %\u0026gt; JSP Action JSP Action XML 구문 안의 구조들을 사용하여 WAS의 동작을 제어한다. \u0026lt;jsp:forward\u0026gt; action 다른 리소스(JSP, html 또는 Servlet과 같은 정적 페이지)로 요청을 전달하는데 사용한다. \u0026lt;jsp:include\u0026gt; action 현재 JSP 페이지에 다른 리소스를 포함시키는데 사용한다. \u0026lt;jsp:useBean\u0026gt; action 해당하는 Bean(자바 객체)이 이미 존재하는지 확인한다. 객체가 없으면 지정된 객체를 생성한다. \u0026lt;jsp:setProperty\u0026gt; action Bean(자바 객체)의 속성을 설정한다. \u0026lt;jsp:getProperty\u0026gt; action 주어진 속성값을 가져오는데 사용되며 이를 문자열로 변환하고 동적인 웹 페이지를 생성하는데 해당 내용을 사용할 수 있다.  용도\n 동적으로 파일을 삽입하고 JavaBeans 구성 요소를 재사용하고 사용자를 다른 페이지로 전달(forward)할 수 있다. https://gmlwjd9405.github.io/2018/11/03/jsp.html  JSP EL (Explression Language)  \u0026lt;%-- JSP 2.0(Preferred) --%\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Name: ${customer.name}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Email: ${customer.email}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;ID: ${customer.id}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; **JSP JSTL ** JSP Scriptlet에서 JSTL로!  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Count to 10 in JSP scriptlet\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;% for(int i=1;i\u0026lt;=10;i++){ %\u0026gt; \u0026lt;%=i%\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;%@ taglib uri=\u0026#34;http://java.sun.com/jsp/jstl/core\u0026#34; prefix=\u0026#34;c\u0026#34;%\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Count to 10 Example (using JSTL)\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;c:forEach var=\u0026#34;i\u0026#34; begin=\u0026#34;1\u0026#34; end=\u0026#34;10\u0026#34; step=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;c:out value=\u0026#34;${i}\u0026#34;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/c:forEach\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 차이점 기능은 동일하나 역할은 다르다.    Servlet JSP     JAVA code html 기반 code   MVC 구조의 Controller 역할 MVC 구조의 View 역할   JSP 보다 빠름 JSP 는 JSP를 자바 코드로 번역하는 과정을 먼저 거치고 컴파일이 필요해서 Servlet보다 느림   모든 protocol 요청을 받음 http 요청만 받음   주된 업무는 client에게 정보를 입력받아 적절한 HTML문서를 돌려주는 역할. JSP는 실행시키면 이 문서가 자동적으로 서블렛으로 컴파일 되어서 실행됨    Request \u0026amp; Response HttpServletRequest  사용자가 서버로 보낸 요청: Request http프로토콜의 request정보를 서블렛에게 전다하는 목적으로 사용됨 헤더정보, 파라미터, 쿠키, URL등의 정보를 읽고 처리하는 메소드를 가지고 있음 body의 stream을 읽어 들이는 메소드를 가지고 있음     메소드 설명     getParameter(?) 요청에 담긴 값을 반환   getAttribute(?) 요청의 속성 값 가져오기   getAttribute(?) 요청의 속성 값 추가   request.getCookies() 쿠키에 대한 정보   request.getSession() 세션에 대한 정보   request.getRequestDispatcher() *     RequestDispatcher는 클라이언트로부터 최초에 들어온 요청을 JSP/Servlet 내에서 원하는 자원으로 요청을 넘기는(보내는) 역할을 수행하거나, 특정 자원에 처리를 요청하고 처리 결과를 얻어오는 기능을 수행하는 클래스입니다.  출처: https://dololak.tistory.com/502 [코끼리를 냉장고에 넣는 방법]\nHttpServletResponse  웹서버의 응답: Response Servlet Container.는 어떤 client가 요청을 보냈는지 알고 있고 해당 client에게 응답을 보내기 위한 HttpServletResponse객체를 생성해서 서블렛에 전달한다. 서블렛은 해당 객체를 이용해 content type, 응답코드, 응답 메세지등을 전송한다. JSP를 활용할 경우, JSP 페이지의 실행 결과를 웹 브라우저에 되돌려 줄 때 사용하는 객체     메소드 설명     PrintWriter getWriter() 응답에 char data를 보내기 위한 방법   setContentType(String) MIME 타입 지정및 글자의 인코딩 지정   response.SendRedirect(url) 웹 서버가 웹 브라우저에게 지정한 페이지로 이동하도록 지시    Servlet Code Example package step01.method; import java.io.IOException; import javax.servlet.Servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /* * client가 요청하는 url값 설정 annotation * https://ip:port/project명/[directory]/file명.html * https://ip:port/project명/[directory]/servletURL매핑값 * http://localhost/step01_basic/encore01 * encore01 -\u0026gt; alias */ @WebServlet(\u0026#34;/encore01\u0026#34;) public class Servlet01Method extends HttpServlet implements Servlet { //get 방식 요청시 자동 호출되는 메소드 \tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;doGet()\u0026#34;); //client가 입력한 데이터 획득 - 문자열 간주 \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \tString id = request.getParameter(\u0026#34;id\u0026#34;); //무조건 반환 타입이 String입니다. id key 자체가 없을 경우 null값 반환 \tString pw = request.getParameter(\u0026#34;pw\u0026#34;); //\t//접속한 client한테 한글 응답 //\t//mime type \u0026amp; 한글 응답이 가능한 설정 //\tresponse.setContentType(\u0026#34;text/html;charset=utf-8\u0026#34;); //\tPrintWriter out =response.getWriter(); \tif(id.equals(\u0026#34;SMITH\u0026#34;) \u0026amp;\u0026amp; pw.equals(\u0026#34;11\u0026#34;)) { //forward \trequest.getRequestDispatcher(\u0026#34;success\u0026#34;).forward(request, response); }else { //redirect \tresponse.sendRedirect(\u0026#34;fail\u0026#34;); } }\t//post 방식 요청시 자동 호출되는 메소드 \tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;doPost*()\u0026#34;); //요청 객체에 한글이 포함되어 있을 경우 깨짐 현상 방지를 위한 설정 \trequest.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); System.out.println(request.getParameter(\u0026#34;name\u0026#34;)); String id = request.getParameter(\u0026#34;id\u0026#34;); //무조건 반환 타입이 String입니다. id key 자체가 없을 경우 null값 반환 \tString pw = request.getParameter(\u0026#34;pw\u0026#34;); if(id.equals(\u0026#34;SMITH\u0026#34;) \u0026amp;\u0026amp; pw.equals(\u0026#34;11\u0026#34;)) { //forward \trequest.getRequestDispatcher(\u0026#34;success\u0026#34;).forward(request, response); }else { //redirect \tresponse.sendRedirect(\u0026#34;fail\u0026#34;); } } } \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Web Form Test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;이름과 성을 입력하세요.\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;encore01\u0026#34; method = \u0026#34;post\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;fname\u0026#34;\u0026gt;아이디:\u0026lt;/label\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;label for=\u0026#34;lname\u0026#34;\u0026gt;비밀번호:\u0026lt;/label\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;pw\u0026#34;\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 이름 : \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;로그인\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://ajdeve.github.io/post/servlet-jsp/","summary":"Servlet \u0026amp; JSP 정의 Servlet: 서블렛은 Java class로서 서버의 요청을 다루기 위해 쓰인다.\n 서블렛을 통해 사용자의 input을 모으거나, DB에서 레코드를 출력한다거나 dynamic web page들을 생성하거나 할 수 있다. 쉽게 말하면 \u0026ldquo;클라이언트의 요구를 받아 그에 대한 처리를 한 후, 결과를 되돌려주는 서버 모듈\u0026quot;이다. 서블릿은 JSP에서 컨텐츠와 비즈니스 로직을 분리한다. JSP가 텍스트 파일 구조인데 비해 서블릿은 자바 클래스 구조이다.  출처: https://ddo-o.tistory.com/77 [공순이의 블로그]\nServlet 돌아가는 과정 서블렛은 Servlet Container (서블렛 컨테이너)에게서 컨트롤된다.","title":"Servlet \u0026 JSP"},{"content":"Vue.js 정의 Vue.js Frontend를 쉽게 접근할 수 있게 하는 JS library\nMVVM Pattern MVC와 비슷하지만 다른 MVVM 패턴\nMVC VS. MVVM MVC: Controller와 Model이 Backend, View가 Frontend MVVM: 모든 요소가 Front이며 Javascript \u0026amp;HTML\n설치 Vue.js 사이트에서 설치 script 가져와 Head tag 전에 삽입 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 중요 문법 Vue Instance 와 Key Attribute \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input tyv-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;  \u0026lt;script\u0026gt; let model = { \u0026#34;name\u0026#34;: \u0026#34;hugo\u0026#34;}; let vm = new Vue({ el: \u0026#34;app\u0026#34;, data: model }); \u0026lt;/script\u0026gt; 중요 문법: v-show, v-if, v-if-else v-show와 v-if\n v-show는 style = display:none; 을 설정해서 condition filtering을 통해 모든 결과중 필요한 결과를 보여주는것 v-if 는 스타일 태그에 관한 변화가 아니라 필터링 된 결과만 출력  ","permalink":"https://ajdeve.github.io/post/vue.js/","summary":"Vue.js 정의 Vue.js Frontend를 쉽게 접근할 수 있게 하는 JS library\nMVVM Pattern MVC와 비슷하지만 다른 MVVM 패턴\nMVC VS. MVVM MVC: Controller와 Model이 Backend, View가 Frontend MVVM: 모든 요소가 Front이며 Javascript \u0026amp;HTML\n설치 Vue.js 사이트에서 설치 script 가져와 Head tag 전에 삽입 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 중요 문법 Vue Instance 와 Key Attribute \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input tyv-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;  \u0026lt;script\u0026gt; let model = { \u0026#34;name\u0026#34;: \u0026#34;hugo\u0026#34;}; let vm = new Vue({ el: \u0026#34;app\u0026#34;, data: model }); \u0026lt;/script\u0026gt; 중요 문법: v-show, v-if, v-if-else v-show와 v-if","title":"Vue.js 시작"},{"content":"Thread VS. Process Thread VS. Process 프로세스는 독립적이며 프로세스 안에는 스레드가 있다. 프로세스에게 주어진 메모리는 공유가 가능하지 않으면 프로세스 안에 있는 스레드들은 자원과 메모리를 공유한다.\n정의 스레드와-프로세스\n특이점  Process는 서로 소통하지 않지만 IPC(Inter Process Communication) 라는게 존재한다 JAVA에는 프로세스라는게 존재하지 않는다, Java.exe 자체가 프로세스다. 프로세스라는 것은 프로그램과 같은 개념으로 볼 수 있다. 동시다발적으로 요청을 처리하기 위해 스레드를 사용할 수 있다.  이해도 향상을 위한 그림 코드 예시 public class MyThread extends Thread { public void run(){ System.out.println(\u0026#34;MyThread running\u0026#34;); } } MyThread myThread = new MyThread(); myTread.start(); OR\nThread thread = new Thread(){ public void run(){ System.out.println(\u0026#34;Thread Running\u0026#34;); } } thread.start(); Thread 스타트로 소환된 thread에서 run이 실행될때 \u0026ldquo;Thread Running\u0026quot;이 출력됨\n","permalink":"https://ajdeve.github.io/post/thread-vs.-process/","summary":"Thread VS. Process Thread VS. Process 프로세스는 독립적이며 프로세스 안에는 스레드가 있다. 프로세스에게 주어진 메모리는 공유가 가능하지 않으면 프로세스 안에 있는 스레드들은 자원과 메모리를 공유한다.\n정의 스레드와-프로세스\n특이점  Process는 서로 소통하지 않지만 IPC(Inter Process Communication) 라는게 존재한다 JAVA에는 프로세스라는게 존재하지 않는다, Java.exe 자체가 프로세스다. 프로세스라는 것은 프로그램과 같은 개념으로 볼 수 있다. 동시다발적으로 요청을 처리하기 위해 스레드를 사용할 수 있다.  이해도 향상을 위한 그림 코드 예시 public class MyThread extends Thread { public void run(){ System.","title":"Thread VS. Process"},{"content":"Web 기본 Web 개발 기술   http 프로토콜 기반의 지원 기술\n  client단 개발 기술\n 화면 구성 html: 구조  서버에 전송하고자 하는 입력 양식 (input from)   css: 보기 좋게 꾸미는 언어 Java script: 브라우저 화면을 동적 처리를 위한 언어  모든 서버단 언어와 소통이 가능 화면단 처리 언어 Java와 non-java와 소통 가능      server단 개발 기술 (back)\n Java 기반: Servle \u0026amp; JSP  servlet  java 기반의 웹 처리 스펙 controller   JSP  Java 코드 보다는 jsp 자체 tag + html tag + css + java script 위주의 화면단 처리 스펙 Java 코드 보다는 jsp 자체 tag 위주의 화면단 처리 스펙 Java의 데이터값을 브라우저 화면에 출력하게 하는 기술 화면 처리 언어 html과 가장 큰 차이점  html은 자바 코드 활용 불가       php, asp, django\u0026hellip;  python 기반의 분석      front + back = full stack\n  Java 는 Servlet과 소통한다.\n","permalink":"https://ajdeve.github.io/post/web01/","summary":"Web 기본 Web 개발 기술   http 프로토콜 기반의 지원 기술\n  client단 개발 기술\n 화면 구성 html: 구조  서버에 전송하고자 하는 입력 양식 (input from)   css: 보기 좋게 꾸미는 언어 Java script: 브라우저 화면을 동적 처리를 위한 언어  모든 서버단 언어와 소통이 가능 화면단 처리 언어 Java와 non-java와 소통 가능      server단 개발 기술 (back)\n Java 기반: Servle \u0026amp; JSP  servlet  java 기반의 웹 처리 스펙 controller   JSP  Java 코드 보다는 jsp 자체 tag + html tag + css + java script 위주의 화면단 처리 스펙 Java 코드 보다는 jsp 자체 tag 위주의 화면단 처리 스펙 Java의 데이터값을 브라우저 화면에 출력하게 하는 기술 화면 처리 언어 html과 가장 큰 차이점  html은 자바 코드 활용 불가       php, asp, django\u0026hellip;  python 기반의 분석      front + back = full stack","title":"Web Beginner Series 1"},{"content":"JAVA Level 1. 기초 메서드 1. System.out 활용 메서드 - 출력 public static void main(String[] args) { System.out.print(\u0026#34;Hello World\u0026#34;); } - String 출력 public static void main(String[] args) { String h = \u0026#34;Hello World\u0026#34;; System.out.print(h); } - String + 출력 public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34; \u0026#34;; String c = \u0026#34;World\u0026#34;; System.out.print(a + b + c); } - String 출력 +, ++, if, == public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34; \u0026#34;; String c = \u0026#34;World\u0026#34;; int i = 1; i++; if (i == 2) { System.out.println(a + b + c); }else { System.out.println(b); } } 2. charAt 활용 메서드 - 출력 charAt, for, ++, String public static void main(String[] args) { String java = \u0026#34;Hello World!\u0026#34;; for(int i = 0; i \u0026lt; java.length(); i++) { char character = java.charAt(i); System.out.print(character); } 3. class 활용 메서드 - Class +, new class A{ String a = \u0026#34;Hello world!\u0026#34;; } public class ExampleSet { public static void main(String[] args) { A a = new A(); System.out.println(a.a); } } - Class +, new, + class B{ String b = \u0026#34;Hello \u0026#34;; } class C{ String c = \u0026#34;world!\u0026#34;; } public class ExampleSet { public static void main(String[] args) { B b = new B(); C c = new C(); System.out.println(b.b + c.c); } } - Class +, Array, new, + class D { String[] d = { \u0026#34;Hello \u0026#34;, \u0026#34;world!\u0026#34; }; } public class ExampleSet { public static void main(String[] args) { D d = new D(); System.out.println(d.d[0] + d.d[1]); } } ","permalink":"https://ajdeve.github.io/post/java1/","summary":"JAVA Level 1. 기초 메서드 1. System.out 활용 메서드 - 출력 public static void main(String[] args) { System.out.print(\u0026#34;Hello World\u0026#34;); } - String 출력 public static void main(String[] args) { String h = \u0026#34;Hello World\u0026#34;; System.out.print(h); } - String + 출력 public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34; \u0026#34;; String c = \u0026#34;World\u0026#34;; System.out.print(a + b + c); } - String 출력 +, ++, if, == public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34; \u0026#34;; String c = \u0026#34;World\u0026#34;; int i = 1; i++; if (i == 2) { System.","title":"JAVA Method Examples"},{"content":"JDBC 환경세팅 CASE: 하나의 Team에는 한명의 Member가 있는 상황 @OneToOne   eclipse에서 new java project 생성\n  마우스 오른쪽 클릭 → configure → maven project\n  마우스 오른쪽 클릭 → configure → JPA project\n  pom.xml setup\n  Dependency \u0026amp; Repository setup\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.persistence-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.2.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.jslsolucoes\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ojdbc6\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;11.2.0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.platform\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-platform-runner\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-engine\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-params\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- @Slf4j 사용을 위한 library 설정 \u0026amp; log4j.properties 필요 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-log4j12\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;oracle\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;ORACLE JDBC Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.atlassian.com/3rdparty/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt;     log4j properties 파일을 src 안으로 복사하고 붙여넣는다.\n  log4j.properties\n# Set root category priority to INFO and its only appender to CONSOLE. log4j.rootCategory= INFO, CONSOLE, daily \\u200B # CONSOLE is set to be a ConsoleAppender using a PatternLayout. log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout log4j.appender.CONSOLE.layout.ConversionPattern=- [%-p] %m%n \\u200B log4j.appender.daily=org.apache.log4j.DailyRollingFileAppender log4j.appender.daily.File=C:\\\\ITStudy\\\\88.log\\\\fiveguys.log #C:\\\\ITStudy\\\\88.log log4j.appender.daily.DatePattern='.'yyyy-MM-dd log4j.appender.daily.layout=org.apache.log4j.PatternLayout log4j.appender.daily.layout.ConversionPattern=- [%-p] %d{dd-MM-yyyy HH:mm:ss} %F %m%n     META INF 안의 persistence.xml 파일 설정\n  persistence.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;persistence version=\u0026quot;2.1\u0026quot; xmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\u0026quot;\u0026gt; \u0026lt;persistence-unit name=\u0026quot;oracleDBUse\u0026quot;\u0026gt; \u0026lt;class\u0026gt;entity2.Member\u0026lt;/class\u0026gt; \u0026lt;class\u0026gt;entity2.Team\u0026lt;/class\u0026gt; \u0026lt;!-- \u0026lt;class\u0026gt;entity.Member\u0026lt;/class\u0026gt; \u0026lt;class\u0026gt;entity.Team\u0026lt;/class\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;class\u0026gt;step01.entity.Dept01\u0026lt;/class\u0026gt; --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:xe\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;SCOTT\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;TIGER\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.OracleDialect\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.id.new_generator_mappings\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;none\u0026quot; /\u0026gt; --\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/persistence-unit\u0026gt; \u0026lt;/persistence\u0026gt; persistence.xml 파일에서 db 접속 정보 설정 tag 확인해서 아이디 패스워드 확인\n    Entity, Test 와 Util java class를 만들어서 테스트 환경 조성\n  Entity 주의사항\n  @Entity 애노테이션 선언\n  persistence.xml 에 등록 (persistence file 눌러 JPA synchronize 하여 class 연동하기)\n  각 컬럼별 이름, 사이즈 조절\n  String 타입은 length로 사이즈 조절\n  Number 타입읁 BigDecimal, precision으로 조절\n  @Column\n  @GeneratedValue(strategy=GenerationType.SEQUENCE\n//콘솔창에 뜨는 해당 사항 drop sequence hibernate_sequence Hibernate: create sequence hibernate_sequence start with 1 increment by 1 3.@Column(length=20, nullable=false)     Team (Parent Class)\n@NoArgsConstructor @AllArgsConstructor @Builder @Getter @Setter @Entity @SequenceGenerator(name=\u0026#34;TEAM_ID_SEQ\u0026#34;, sequenceName = \u0026#34;TEAM_SEQ\u0026#34;, initialValue = 1, allocationSize = 50) public class Team { @Id @GeneratedValue (strategy=GenerationType.SEQUENCE, generator=\u0026#34;TEAM_ID_SEQ\u0026#34;) @Column (name=\u0026#34;team_id\u0026#34;) private Long teamId; @Column (name = \u0026#34;team_name\u0026#34;, length = 20) private String teamName; }   Member (Child Class)\n@NoArgsConstructor @AllArgsConstructor @Builder @Getter @Setter @Entity @SequenceGenerator(name=\u0026#34;MEMBER_ID_SEQ\u0026#34;, sequenceName = \u0026#34;MEMBER_ID\u0026#34;, initialValue = 1, allocationSize = 50) public class Member { @Id @GeneratedValue (strategy=GenerationType.SEQUENCE, generator=\u0026#34;MEMBER_ID_SEQ\u0026#34;) //sequence  @Column (name=\u0026#34;member_id\u0026#34;) private Long memberId; @Column (name = \u0026#34;member_name\u0026#34;, length = 20) private String memberName; @Column (name=\u0026#34;member_age\u0026#34;) private Integer memberAge; @OneToOne @JoinColumn (name = \u0026#34;team_id\u0026#34;, referencedColumnName = \u0026#34;team_id\u0026#34;) private Team teamId; }     Test\nEntityManager의 개별 메소드로 crud 하는 실행 클래스\npublic class RunningTest { //step02  @Test public void runningTest() { EntityManager em = PublicCommon.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try { Team t1 = Team.builder().teamName(\u0026#34;team A\u0026#34;).build(); em.persist(t1); Team t2 = Team.builder().teamName(\u0026#34;team B\u0026#34;).build(); em.persist(t2); // member 객체 생성 후 insert 시도할 경우 member의 teamid는 이미 존재하는 team 이어야함  Member m1 = Member.builder().memberName(\u0026#34;유재석\u0026#34;).teamId(t1).memberAge(50).build(); em.persist(m1); Member m2 = Member.builder().memberName(\u0026#34;강재석\u0026#34;).teamId(t2).memberAge(40).build(); em.persist(m2); tx.commit(); } catch(Exception e) { e.printStackTrace(); } finally { em.close(); } }   Util\n실행 클래스에 활용될 Util 클래스 개발\n EntiyManagerFactory EntityManager  package util; import javax.persistence.EntityManager; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class PublicCommon { //db driver처럼 한번만 메모리 생성 후 저장 및 쭉 재사용  private static EntityManagerFactory emf; //멤버변수 초기화  static { emf = Persistence.createEntityManagerFactory(\u0026#34;oracleDBUse\u0026#34;); } //CRUD 로직별 생성 및 client는 공유 금지  //EntityManager 반환  public static EntityManager getEntityManager() { return emf.createEntityManager(); } //자원반환 em.close()는 매번 상황에 맡겨서 하기  public static void close(EntityManager em) { emf.close(); } }     ","permalink":"https://ajdeve.github.io/post/jdbc1/","summary":"JDBC 환경세팅 CASE: 하나의 Team에는 한명의 Member가 있는 상황 @OneToOne   eclipse에서 new java project 생성\n  마우스 오른쪽 클릭 → configure → maven project\n  마우스 오른쪽 클릭 → configure → JPA project\n  pom.xml setup\n  Dependency \u0026amp; Repository setup\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.persistence-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.2.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.jslsolucoes\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ojdbc6\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;11.2.0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.platform\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-platform-runner\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.","title":"JDBC 환경세팅"},{"content":"JDBC\u0026amp;JPA JDBC, JPA/Hibernate를 사용할때 제일 헷갈리는 부분을 아래와 같이 정리했다.\nflush() : DB에 실제 쿼리를 날려 execute하는 기능이며 commit이 아니기에 DB에 반영이 되지 않는다.\nclear() : 영속성 컨텍스트에 저장한 데이터를 지워버린다.\ncommit() : DB에 저장,수정,삭제를 반영한다.\nrollback:() : DB에 저장하지 않고 영속성 컨텍스트 데이터를 날린다.\n","permalink":"https://ajdeve.github.io/post/jdbc0/","summary":"JDBC\u0026amp;JPA JDBC, JPA/Hibernate를 사용할때 제일 헷갈리는 부분을 아래와 같이 정리했다.\nflush() : DB에 실제 쿼리를 날려 execute하는 기능이며 commit이 아니기에 DB에 반영이 되지 않는다.\nclear() : 영속성 컨텍스트에 저장한 데이터를 지워버린다.\ncommit() : DB에 저장,수정,삭제를 반영한다.\nrollback:() : DB에 저장하지 않고 영속성 컨텍스트 데이터를 날린다.","title":"JDBC\u0026JPA"}]